// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Text;
using System.IO;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
#if UNITY_4_0_0 ||UNITY_4_0 || UNITY_4_0_1||UNITY_4_1||UNITY_4_2||UNITY_4_3||UNITY_4_4||UNITY_4_5||UNITY_4_6||UNITY_4_7||UNITY_4_8||UNITY_4_9
namespace OnePStudio.AEPToUnity4
#else
namespace OnePStudio.AEPToUnity5
#endif
{
	public class EditorUtil
	{
		public class AnimationClipSettings
		{
			SerializedProperty m_Property;
			
			private SerializedProperty Get (string property) { return m_Property.FindPropertyRelative(property); }
			
			public AnimationClipSettings(SerializedProperty prop) { m_Property = prop; }
			
			public float startTime   { get { return Get("m_StartTime").floatValue; } set { Get("m_StartTime").floatValue = value; } }
			public float stopTime	{ get { return Get("m_StopTime").floatValue; }  set { Get("m_StopTime").floatValue = value; } }
			public float orientationOffsetY { get { return Get("m_OrientationOffsetY").floatValue; } set { Get("m_OrientationOffsetY").floatValue = value; } }
			public float level { get { return Get("m_Level").floatValue; } set { Get("m_Level").floatValue = value; } }
			public float cycleOffset { get { return Get("m_CycleOffset").floatValue; } set { Get("m_CycleOffset").floatValue = value; } }
			
			public bool loopTime { get { return Get("m_LoopTime").boolValue; } set { Get("m_LoopTime").boolValue = value; } }
			public bool loopBlend { get { return Get("m_LoopBlend").boolValue; } set { Get("m_LoopBlend").boolValue = value; } }
			public bool loopBlendOrientation { get { return Get("m_LoopBlendOrientation").boolValue; } set { Get("m_LoopBlendOrientation").boolValue = value; } }
			public bool loopBlendPositionY { get { return Get("m_LoopBlendPositionY").boolValue; } set { Get("m_LoopBlendPositionY").boolValue = value; } }
			public bool loopBlendPositionXZ { get { return Get("m_LoopBlendPositionXZ").boolValue; } set { Get("m_LoopBlendPositionXZ").boolValue = value; } }
			public bool keepOriginalOrientation { get { return Get("m_KeepOriginalOrientation").boolValue; } set { Get("m_KeepOriginalOrientation").boolValue = value; } }
			public bool keepOriginalPositionY { get { return Get("m_KeepOriginalPositionY").boolValue; } set { Get("m_KeepOriginalPositionY").boolValue = value; } }
			public bool keepOriginalPositionXZ { get { return Get("m_KeepOriginalPositionXZ").boolValue; } set { Get("m_KeepOriginalPositionXZ").boolValue = value; } }
			public bool heightFromFeet { get { return Get("m_HeightFromFeet").boolValue; } set { Get("m_HeightFromFeet").boolValue = value; } }
			public bool mirror { get { return Get("m_Mirror").boolValue; } set { Get("m_Mirror").boolValue = value; } }
		}

		static public UnityEngine.Color HexToColor(string hex)
		{
			try
			{
				byte r = byte.Parse(hex.Substring(0,2), System.Globalization.NumberStyles.HexNumber);
				byte g = byte.Parse(hex.Substring(2,2), System.Globalization.NumberStyles.HexNumber);
				byte b = byte.Parse(hex.Substring(4,2), System.Globalization.NumberStyles.HexNumber);
				byte a = byte.Parse(hex.Substring(6,2), System.Globalization.NumberStyles.HexNumber);

				return new UnityEngine.Color(r/255.0f,g/255.0f,b/255.0f, a/255.0f);
			}
			catch
			{
				return new UnityEngine.Color(1,1,1,1);
			}
		}
		public static List<string> LoadStringByLine(string text)
		{
			List<string> listLine = new List<string> ();
			string [] temp=text.Split(new string[]{ "\n"},StringSplitOptions.RemoveEmptyEntries);
			listLine.AddRange(temp);
			return listLine;
		}

		public static List<string> Load(string fileName)
		{
			List<string> listLine = new List<string> ();
			// Handle any problems that might arise when reading the text
			try
			{
				string line;
				// Create a new StreamReader, tell it which file to read and what encoding the file
				// was saved as
				StreamReader theReader = new StreamReader(fileName, Encoding.Default);
				
				// Immediately clean up the reader after this block of code is done.
				// You generally use the "using" statement for potentially memory-intensive objects
				// instead of relying on garbage collection.
				// (Do not confuse this with the using directive for namespace at the 
				// beginning of a class!)
				using (theReader)
				{
					// While there's lines left in the text file, do this:
					do
					{
						
						line = theReader.ReadLine();

						if (line != null)
						{
							listLine.Add(line);
						}
					}
					while (line != null);
					// Done reading, close the reader and return true to broadcast success    
					theReader.Close();
				}
			}
			
			catch (Exception e)
			{
				Console.WriteLine("{0}\n", e.Message);
			}
			return listLine;
		}
		public static string LoadAllFileToString(string fileName)
		{
			string content="";
			// Handle any problems that might arise when reading the text
			try
			{
				// Create a new StreamReader, tell it which file to read and what encoding the file
				// was saved as
				StreamReader theReader = new StreamReader(fileName, Encoding.Default);
				
				// Immediately clean up the reader after this block of code is done.
				// You generally use the "using" statement for potentially memory-intensive objects
				// instead of relying on garbage collection.
				// (Do not confuse this with the using directive for namespace at the 
				// beginning of a class!)
				using (theReader)
				{
					content = theReader.ReadToEnd();
					// Done reading, close the reader and return true to broadcast success    
					theReader.Close();
				}
			}
			
			catch (Exception e)
			{
				Console.WriteLine("{0}\n", e.Message);
			}
			return content;
		}
		static public string GetFullPathBone(Transform boneRoot,Transform current)
		{
			string fullPath=current.name;
			Transform tran=current;
			while(true)
			{
				if(tran.parent==null||tran.parent==boneRoot)
				{
					break;
				}
				else
				{
					fullPath=tran.parent.name+"/"+ fullPath;
					tran=tran.parent;
				}
			}
			return fullPath;
		}
		public static string AnimatorInfoJson()
		{
			string str="";
			str="{\"rootPosition\":{\"x\":0,\"y\":0,\"z\":0},\"rootRotation\":{\"eulerAngles\":{\"x\":0,\"y\":0,\"z\":0},\"x\":0,\"y\":0,\"z\":0,\"w\":1},\"applyRootMotion\":false,\"linearVelocityBlending\":false,\"animatePhysics\":false,\"updateMode\":\"Normal\",\"bodyPosition\":{\"x\":0,\"y\":0,\"z\":0},\"bodyRotation\":{\"eulerAngles\":{\"x\":270,\"y\":null,\"z\":0},\"x\":0,\"y\":0,\"z\":null,\"w\":9.183409E-41},\"stabilizeFeet\":false,\"feetPivotActive\":1,\"speed\":1,\"cullingMode\":\"AlwaysAnimate\",\"playbackTime\":-1,\"recorderStartTime\":-1,\"recorderStopTime\":-1,\"runtimeAnimatorController\":{\"layers\":[{\"name\":\"Base Layer\",\"stateMachine\":{\"states\":[],\"stateMachines\":[],\"defaultState\":null,\"anyStatePosition\":{\"x\":50,\"y\":20,\"z\":0},\"entryPosition\":{\"x\":50,\"y\":120,\"z\":0},\"exitPosition\":{\"x\":800,\"y\":120,\"z\":0},\"parentStateMachinePosition\":{\"x\":800,\"y\":20,\"z\":0},\"anyStateTransitions\":[],\"entryTransitions\":[],\"behaviours\":[],\"name\":\"Base Layer\",\"hideFlags\":\"HideInHierarchy\"},\"avatarMask\":null,\"blendingMode\":\"Override\",\"syncedLayerIndex\":-1,\"iKPass\":false,\"defaultWeight\":0,\"syncedLayerAffectsTiming\":false}],\"parameters\":[],\"name\":\"AEP Animation\",\"hideFlags\":\"None\"},\"avatar\":null,\"layersAffectMassCenter\":false,\"logWarnings\":true,\"fireEvents\":true,\"enabled\":true,\"tag\":\"Untagged\",\"name\":\"AEP Animation\",\"hideFlags\":\"None\"}";
			return str;
		}
	}
}

